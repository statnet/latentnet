\name{latentnet-internal}
\title{Internal latentnet Objects}

\alias{DistMatrix}
\alias{InitErgmm.latentcov}
\alias{InitErgmm.latent}
\alias{InitErgmm.latentcluster}
\alias{ergmm.Cprepare.latent}
\alias{ergmm.getmodel.latent}
\alias{ergmm.getterms.latent}
\alias{ergmm.gettermnames.latent}
\alias{ergmm.latent}
\alias{ergmm.statseval.latent}
\alias{ergmm.latentplot}
\alias{mlpY.grad.plot}
\alias{mlpY.plot}
\alias{mlpYmdsZ.grad.plot}
\alias{mlpYmdsZ.plot}
%
\alias{ergmm.geodesicmatrix}
\alias{ergmm.geodesicmatrix.edgelist}
\alias{ergmm.latentcluster}
\alias{ergmm.MCMCacf}
\alias{ergmm.procAdj}
\alias{ergmm.procAdj.fcnt}
\alias{ergmm.statseval.latentcluster}
\alias{ergmm.statseval.latent1cluster}
\alias{is.latent}
\alias{is.latent.cluster}
\alias{klswitch.c}
\alias{latent.wrapper}
\alias{lpz.dist}
\alias{mcmc.diagnostics.default}
\alias{mlpY}
\alias{mlpY0}
\alias{mlpY0.grad}
\alias{mlpY.grad}
\alias{mlpYmdsZ}
\alias{mlpYmdsZ.grad}
\alias{mlpYnull}
\alias{mlpY.cluster}
\alias{mlpY.cluster0}
\alias{mlpY.cluster0.grad}
\alias{mlpY.cluster.grad}
\alias{mlpY.clustermdsZ}
\alias{mlpY.clustermdsZ.grad}
\alias{mlpY.clusternull}
\alias{mvimode}
\alias{ergmm.permutation}
\alias{plot.mcmc.ergmm}
\alias{print.raftery.diag.ergmm}
\alias{rergm.ergmm.latent}
\alias{rergm.ergmm.latent.sociomatrix}
\alias{ergmm.set.mfrow}
\alias{traceplot.ergmm}
\alias{ergmm.add.contours}
\alias{ergmm.drawcircle}
\alias{ergmm.drawpie}
\alias{ergmm.labelswitch}
\alias{ergmm.midarrow}
\alias{ergmm.plinfo.latent}
\alias{network.dyadcount}
\alias{robust.inverse}
%
% These need to be documented!
%
\alias{summary.statsmatrix.ergmm}
\alias{is.invertible}

\description{
  Internal latentnet functions.
}
%\usage{
%}
%\details{
%  Most of these are not to be called by the user.
%}
%\arguments{
% \item{\dots}{Type help(package="latentnet") to get started.}
%}
\seealso{ergmm}
\keyword{internal}
