\name{latentnet-internal}
\title{Internal latentnet Objects}

%
% Genuinely internal
%

\alias{ergmm.tofit.resolve}
\alias{extraneous.argcheck}
\alias{inv.fit.vars}
\alias{is.latent}
\alias{is.latent.cluster}
\alias{is.receiver}
\alias{is.sender}
\alias{kief.wolf2.optim}
\alias{kief.wolf.optim}  
 
\alias{pack.optim}
\alias{path.to.me}   
\alias{proc.sample.ergmm}
\alias{proc.Z.mean.C} 
\alias{reg.fit.vars}

\alias{not.given}
\alias{nullapply}
\alias{thin.ergmm}
\alias{trimmed.mean}
\alias{unpack.optim}  

\alias{ergmm.tuner}
\alias{ergmm.labelswitch}
\alias{klswitch.C}
\alias{labelswitch.sample.ergmm}
\alias{nearest.perm}
\alias{ergmm.MCMCacf} 
\alias{ergmm.permutation}
\alias{ergmm.statseval}

\alias{FIT_ALL}
\alias{FIT_MLE}
\alias{ERGMM.PAR_LLK_NAMES}
\alias{ERGMM.PAR_VAR_NAMES}
\alias{PRIOR_NAMES}

\alias{bayesmbc}
\alias{bayesmbc.MCMC.C}

\alias{dsclinvchisq}
\alias{nlog.double.eps}
\alias{robust.inverse}

\alias{coords.1D} 
\alias{ergmm.drawcircle}
\alias{ergmm.drawpie}
\alias{ergmm.midarrow}
\alias{ergmm.plotting.region}
\alias{ergmm.plotting.vertex.radius} 

\alias{ergmm.fit.deps}
\alias{ergmm.geodesicmatrix}
\alias{ergmm.geodesicmatrix.edgelist}
\alias{ergmm.get.model}
\alias{ergmm.initvals}
\alias{find.clusters} 

\alias{GS.orth.matrix} 
\alias{P.free.all}

\alias{InitErgmm.absdiff}
\alias{InitErgmm.latent}
\alias{InitErgmm.latentcov}
\alias{InitErgmm.nodematch}
\alias{InitErgmm.receivercov}
\alias{InitErgmm.rreceiver}
\alias{InitErgmm.rsender}
\alias{InitErgmm.rsociality}
\alias{InitErgmm.sendercov}
\alias{InitErgmm.socialitycov}

\alias{cmp.lists}
\alias{merge.lists}
\alias{sum.lists}
\alias{filter.list}
\alias{zero.list}

\alias{best.avail.Z.K.ref.ergmm}
\alias{best.avail.Z.ref.ergmm}

\alias{gmmajump}

\alias{ergmm.MCMC.C}
\alias{ergmm.MCMC.snowFT}
\alias{ergmm.MCMC.snowFT.slave}
\alias{run.proposal}
\alias{run.proposal.snowFT}
\alias{run.proposal.snowFT.slave}

\alias{seldrop}
\alias{sim.1.ergmm}
\alias{switch.Q.K}

\alias{post.predict.C}
\alias{post.predict.R}

%
% These might be worth documenting
%

\alias{print.ergmm.model}
\alias{ergmm.model}
\alias{ergmm.model.object}

\alias{getYm}
\alias{bipartite.augment}
\alias{observed.dyads}

\alias{statsreeval.ergmm}

\alias{ergmm.loglike}
\alias{ergmm.loglike.C}
\alias{ergmm.loglike.grad}
\alias{ergmm.lp}
\alias{ergmm.lpBeta}
\alias{ergmm.lpBeta.grad}
\alias{ergmm.lp.grad}
\alias{ergmm.lp.grad.approx}
\alias{ergmm.lpLV}
\alias{ergmm.lpLV.grad}
\alias{ergmm.lpRE}
\alias{ergmm.lpRE.grad}
\alias{ergmm.lpREV}
\alias{ergmm.lpREV.grad}
\alias{ergmm.lpZ}
\alias{ergmm.lpZ.grad}
\alias{ergmm.eta}
\alias{ergmm.EY}
\alias{lp.works}

\alias{cov.beta.ext}
\alias{get.init.deltas}
\alias{get.sample.deltas}

\alias{find.mle}
\alias{find.mle.loop}
\alias{find.mpe}
\alias{find.pmode.loop}
\alias{find.mkl}

\alias{add.mcmc.mle.mle.ergmm}
\alias{add.mcmc.pmode.pmode.ergmm}
\alias{add.mkl.mbc.ergmm}
\alias{add.mkl.pos.ergmm}

\description{
  Internal latentnet functions.
}
%\usage{
%}
%\details{
%  Most of these are not to be called by the user.
%}
%\arguments{
% \item{\dots}{Type help(package="latentnet") to get started.}
%}
\seealso{ergmm}
\keyword{internal}
